## 4. 右值引用与移动语义

首先给出一个参考链接，个人觉得是介绍右值引用，移动语义，移动构造函数和移动赋值运算符比较好的文章：https://www.jianshu.com/p/d19fc8447eaa 。

### 1. 左值与右值的基本概念

cpp中所有的值都必须是左值或者右值其中之一。cpp中对**左值**和**右值**的定义是：

+ **深层含义上的定义：一个表达式中的左值是表达式结束后仍然存在的持久对象，右值是在表达式结束后就被销毁的临时变量或者是字面值。**
+ **语法上的定义：可以进行取地址操作的具名值是左值，无法进行取地址操作的无名值是右值。**

例如：

```
int a=2;       // a是左值，表达式结束后仍然存在；2是右值，在表达式结束后就不复存在
int c=rand();  // c是左值，表达式结束后仍然存在；rand()作为函数的返回值，是右值，在表达式结束后就不存在
Element e=Element();  // e是右值，表达式结束后仍然存在；Element()是一个临时对象，是右值，在表达式结束后就不复存在
```

在cpp11中则对右值继续进行了细分，将右值细分为**临时值**和**字面值**，例如2, "abc"是字面值，而函数返回值，临时对象都属于临时值。但是在实际生产环境中，不必过于细分，统一称为右值即可。

### 2. 左值引用与右值引用

在cpp98/03中引入了左值引用，左值引用是给左值（变量）取的别名，但是不存在右值引用。直到cpp11才引入了右值引用，可以为右值取名。

在cpp11中使用&表示左值引用，使用&&表示右值引用，例如：

```
int a=0;    // a是左值，0是右值
int &b=a;   // b是左值引用
int &&c=0;  // c是右值引用
```

右值引用的主要作用是：

+ **持久化右值**：对右值创建右值引用后，右值得到了一个新的别名从而被持久化，其生命期被延长到与右值引用相同。右值引用可以当作左值使用，从而可以避免开销巨大的拷贝操作。

下面的这个例子非常经典，可以用来理解右值引用的主要作用。

```
int a=rand();   // rand()的返回值是临时值，通过将临时值拷贝给a得到了函数返回值
int &&b=rand(); // rand()的返回值是临时值，通过右值引用使得临时值持久化，过程中不涉及到任何拷贝操作
function(Element());  // Element()创建了一个临时值，调用function时会拷贝该临时对象到函数形参变量上
Element &&c=Element();// 为Element()这个临时值创建了一个右值引用c，右值引用本身可以当作左值使用进行传参，整个过程中只创建了Element()一个临时变量，没有任何拷贝操作
function(c);          
```

### 3. 类的移动构造函数和移动赋值运算符

在函数调用，传参，赋值等一系列操作中，均需要使用拷贝构造函数和拷贝赋值运算符，但是在一些情况下，使用拷贝操作是非常低效的，例如：

```
Array array;     // Array是一个容器类，Element是一个元素类
array.push(Element("abc"));   // Element是一个右值，直接将右值用于传参，会调用Element的拷贝构造函数拷贝一份临时值的副本给形参，然后临时值被销毁，效率极低，临时值本身也没有得到很好的利用。
```
上述情形中，实际上没有必要拷贝一份对象，为了直接利用右值Element()本身，只需要为Element类创建移动构造函数和移动赋值运算符即可。类的移动构造函数和移动赋值运算符需要做的工作总结为：

+ **接受传入的右值引用参数other，该引用不能是底层const的。**
+ **对于拷贝源对象的非指针成员a，直接将其赋值给当前对象的同名成员变量上，即: (\*this).a=other.a。**
+ **对于拷贝源对象的指针成员b，将其赋值给当前对象的同名成员变量上后，修改该指针成员b为nullptr，即: (\*this).b=other.b; other.b=nullptr。**
+ **移动赋值运算符需要额外做防止自身拷贝和返回(\*this)两个操作。

如下图所示。
![avatar](https://github.com/Happyxianyueveryday/cppnote/blob/master/4.%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/pics/4427263-81a47fdc9b8d9e98.webp)

为什么对于拷贝源对象指针成员b，需要在移动后将其赋值为nullptr呢？这是为了防止二次析构，如果不赋值为nullptr，拷贝源对象会对其指向的对象析构一次，当前对象也会析构一次，从而引发运行时错误。

### 4. 左值转换为右值——std::move
关于拷贝/移动构造函数，拷贝/移动赋值运算符，实际上相互为重载关系。cpp同样按照实参类型列表来决定调用拷贝还是移动函数，调用规则具体如下：

+ **若拷贝源为右值，则调用移动构造函数/移动赋值运算符。**
+ **若拷贝源为左值，则调用拷贝构造函数/拷贝构造运算符。**

但是有的时候，即使拷贝源为左值，但是我们仍然想要指定调用移动构造函数/移动赋值运算符，这时就需要使用到std::move语义：

+ **std::move(a)将左值a转换为右值引用返回。**

下面提供了一个例子，a虽然是一个左值，但是生命期仅仅在每次循环中，这时同样可以使用std::move()，指定调用移动构造函数。

```
for(int i=0;i<size;i++)
{
    string a="abc";
    Element element1=new Element(a);   // 调用std::string的拷贝构造函数，存在一次拷贝，性能开销较大
    Element element2=new Element(std::move(a));  // 使用std::move(a)将左值转换为右值引用，这时调用Element类的移动构造函数，不存在拷贝过程。
}
```


